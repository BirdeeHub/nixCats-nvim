=======================================================================================
Flake Help                                                      *nixCats.flake*

A Lua-natic's neovim flake, with extra cats! nixCats!

This is the documentation for the flake itself.
This flake uses nix for importing plugins, lsps, dependencies, and more,
in place of usual nvim package managers such as packer, lazy or mason.

Everything else is done in a regular lua config style.
Download in flake.nix and then, simply pretend the root of the flake 
is the root of your Lua config. 

1 exception, when wrapRc = true, 
`stdpath('config')` will still point to ~/.config/<configDirName>.
But your lua config will be in the store.
This is ok, because most of the reason for a plugin to use
it would be to find something outside the directory. 
Inside is mostly handled by vim.
You can use debug.getinfo(1, "S").source:sub(2) or something similar 
to get current script directory for your uses, if ever necessary.
Keep in mind they will be read-only and theres definitely a more
in built vim way to do it.

*******************************************************
One IMPORTANT note:
When editing the files within the flake directory,
nix will not package a new file if it isn't staged in git.
run git add before rebuilding it whenever adding a new file.
Using wrapRc = true would mean this also applies to lua files.
In fact, when wrapRc = true, even changes within a lua file
will not be reflected unless you run git add.
*******************************************************

Related:
For detecting what was included by 
the flake in your Lua, see:
:help `nixCats`

=======================================================================================
Flake Inputs:                                            *nixCats.flake.inputs*

If they dont have an extra build step, and are not on nixpkgs,
you may use this format to import them, replacing the fields marked with <>
>nix
    "plugins-<pluginName>" = {
      url = "github:<userName>/<repositoryName>";
      flake = false;
    };
<
If the plugin has a dot in it's name, you should name it something else.
The name here only affects the filename of the overall plugin, and should
only affect things like packadd that refer to the actual filename of the
plugin. Usually I would replace it with - or _
You will then add it to categoryDefinitions later with the NEW name.
You may also use this to pin the version of a plugin.
More info on flake url syntax at:
https://nixos.org/manual/nix/stable/command-ref/new-cli/nix3-flake.html#examples


If they have a build step or are not a plugin, 
i.e. an lsp, dont name them in that format.

If they are on nixpkgs, you dont necessarily need to put them in inputs,
because you will be able to access them through pkgs.vimPlugins variable later.

Most plugins will not require you to use this section due to being on nixpkgs.
But you may still use it to pin the plugin to a specific version.

Context for later:

If they have a build step, you will deal with them in overlays/customBuildsOverlay.nix
then import them into a category of the builder. 
(assuming nixpkgs hasn't already done it!!)

If they are not a plugin:
You will import them into a category of the builder under lspsAndDeps, 
unless they are for build time, then put them under propagatedBuildInputs

=======================================================================================
Flake Outputs Introduction                              *nixCats.flake.outputs*

With our inputs to our flake taken care of:

First, we call flake utils to get system variable for all default systems.
Then we import our nixCats utils, so that we can access things
like overlay <1>, utils.standardPluginOverlay.

                                               *nixCats.flake.outputs.overlays*
Then, we define our overlays.
We have 2 main overlays to discuss.

<1>
-- The first is utils.standardPluginOverlay:
You do not need to edit it to use it.

It takes all the inputs named in the format
'plugins-somepluginname' and makes them into plugins. 
If the plugin doesn't have a build step,
and it wasnt on nixpkgs, then use this method.
Access them to add them to a category of the builder function 
with 'pkgs.neovimPlugins.somepluginname'

<2>
-- The second is overlays/customBuildsOverlay.nix:

If you need to interact with one of these overlays, it will be this one.
You should not need to do it much. 
overlays/default.nix imports this overlay and any others like it.
see :help `nixCats.flake.nixperts.overlays`

It is used for defining plugins with build steps that 
were not well handled by nixpkgs.
It is passed flake inputs, and super is pkgs.
Define the things within the file. 
Then, access plugins defined there later 
with 'pkgs.nixCatsBuilds.somepluginname'

If you decide you wish to split your customBuildsOverlay up, 
see :help `nixCats.flake.nixperts.overlays`
or look at the overlays/default.nix file.

<IMPORTANT> When defining your overlays,
all overlays that are not defined via
overlay <1>, the standardPluginOverlay, should be
defined in a SEPARATE LIST named <otherOverlays>.
Otherwise the exports will not work correctly.

<pkgs>
-- After the overlays we wish to include are all defined:

We now generate the pkgs set that contains all the nixpkgs and overlay packages, 
and the system variable from flake-utils. If you imported any flakes with
overlays, add their overlay here as well.

pkgs will contain all our plugins and programs we will need from this point on.
with the occasional exception of a flake that has no overlays, which you just
add to a category directly.

---------------------------------------------------------------------------------------
Neovim Builder Creation:                        *nixCats.flake.outputs.builder*

Now we define our builder function.
We do this by importing ./nix/builder/default.nix which is
a function that takes 6 arguments.
Right now we are going to call it with just the first 5 of them. This will
leave us with a function that takes 1 argument.
That argument is the name of the neovim package to be packaged.

1. The path to the help directory so that it is always included in outputs of
     this flake.
2. The path to the lua to include (in the flake, we use the self variable to get
     this path and wrap the lua when wrapRc = true)
3. The pkgs set so that it can use it for making its own derivations.
4. our function that takes an individual package definition
     and returns a set of categoryDefinitions.
5. our set of packageDefinitions see: `nixCats.flake.outputs.packageDefinitions`

It is now a function that takes a name, and returns your chosen neovim package.
>nix
      baseBuilder = import ./nix/builder "${self}/nix/nixCatsHelp";
      nixCatsBuilder = baseBuilder
        self pkgs categoryDefinitions packageDefinitions;
        # notice how it doesn't care the last 2 are defined lower in the file?
<
      # We defined baseBuilder separately 
      # so that we can easily export it later.
      # this will ensure that other flakes that import 
      # only this function from our flake may still access the help.

---------------------------------------------------------------------------------------
                                            *nixCats.flake.outputs.categories*
Then we define what is in our categories!
This section is a function that takes the package definition for this
particular package as an argument.
The builder will call it with that argument, you may use it.
This allows categoryDefinitions to access their packages categories and settings,
which allows categoryDefinitions to be much more dynamic.

These are the things you can return:
>nix
  categoryDefinitions = packageDef: {
<
<propagatedBuildInputs> 
  a flexible set of categories, each containing a list of 
  internal BUILD TIME dependencies. Will also be available to the devShell.

<lspsAndRuntimeDeps>
  a flexible set of categories, each containing a list of LSP's or 
  other internal runtime dependencies such as ctags or debuggers
  these are available to the PATH while within the neovim program.
  this includes the neovim terminal.

<startupPlugins>
  a flexible set of categories, each containing a list of startup plugins.
  Startup plugins are loaded and can be required. 

<optionalPlugins>
  a flexible set of categories, each containing a list of optional plugins.
  Optional plugins need to be added with packadd before being required.

<environmentVariables>
  a flexible set of categories, each containing an ATTRIBUTE SET of 
  EnvironmentVariableName = "EnvironmentVariableValue";

<extraWrapperArgs>
  a flexible set of categories, each containing a list of 
  extra wrapper arguments.
  If you don't know what that is, see here:
github.com/NixOS/nixpkgs/blob/master/pkgs/build-support/setup-hooks/make-wrapper.sh

<extraLuaPackages>
  a flexible set of categories, each containing a list of FUNCTIONS 
  that return lists of extra Lua packages.
  These functions are the same thing that you would pass to lua.withPackages.

<extraPythonPackages> <extraPython3Packages> 
  TWO flexible sets of categories, one for python and the other for python3,
  each containing a list of FUNCTIONS that return lists of python packages.
  These functions are the same thing that you would pass to python.withPackages.

  <optionalLuaAdditions>* It can also take a lua string that can be run.
    Yes it can access nixCats.
    It is not the recommended way to create lua for this flake, 
    but it may be useful in some edge cases of editing flake imports 
    of other already configured setups following the nixCats format.
    Therefore, I have included this option.
}

how this function actually works is covered in 
:help `nixCats.flake.nixperts.nvimBuilder`
In essence, the contents of each set listed here are filtered
based on the packageDefinitions set you provide, 
where by including categoryname = true; you enable that category.
:help `nixCats.flake.outputs.packageDefinitions`

---------------------------------------------------------------------------------------
Settings Profiles:                             *nixCats.flake.outputs.settings*

These are the defaults:
>nix
  settings = {
    defaults = {
<
      # do you want to package the lua from this flake in the store?
      # or would you rather it just read it in your .config/<configDirName>?
      # nixCats and this help will work either way.
      # this value will also be included in nixCats.
      # The false setting is useful for fast iteration of lua changes.
      # But it restricts where you may save the lua to the .config directory.
>nix
      wrapRc = true;
<
      # What should the name of the folder within standard directories
      # i.e. .config, .local/share, .local/state, .cache, etc... be?
      # This option is very useful when you want 
      # to clone an unwrapped config straight to the .config dir.
      # It is also helpful to prevent other nvim packages sharing data folders.
      # see :help `$NVIM_APPNAME`
>nix
      configDirName = "nvim";

      # and the rest:
      viAlias = false;
      vimAlias = false;
      withNodeJs = false;
      withRuby = true;
      extraName = "";
      withPython3 = true;

      # use this to pin a specific neovim version.
      # import it in flake inputs with flake = false,
      # then put inputs.neovim (or whatever you called it) here.
      # It will be used to override the source for neovim-unwrapped.
      nvimSRC = null;
    };
  };
<
If you wish to have something different, you may define some or all of these
options, in a set within the settings set to be included in the packaging section below.

---------------------------------------------------------------------------------------
Package Generation:                           *nixCats.flake.outputs.packageDefinitions*

generate packages by calling that builder function we just created.
Place them in the packageDefinitions set.

First, pick the set of settings you wish to include.

Then, pass it a set of named boolean values like this:
{ categoryname1 = true; categoryname2 = false; etc... }
False may be omitted. True may not be omitted.
Only true matters for what plugins will be added.

These categories are defined in the Builder function above 
by placing named lists of plugins in the flexible sets provided.
The category names are the names of those lists. 
Add a new list, then enable the category here.

If you have categories with the same name in 
multiple different sets outlined above in the builder,
all plugins in those categories will be
included when you set "thatname = true;" here.
hence, general = true; will include the general lspsAndDeps category,
as well as the general startupPlugins category.

an example package definition:
>nix
  packageDefinitions = {
    nixCats = { 
      setting = settings.nixCats;
      categories = {
        custom = true;
        gitPlugins = true;
        general = true;
        neonixdev = true;

        # this does not have an associated category of plugins, 
        # but lua can still check for it
        lspDebugMode = false;

        # you could also pass something else and it calls 
        # builtins.toString on it and passes it in as a string
        theBestCat = "says meow!!!";
        # maybe you need to pass a port or path in or something idk.
        # you could :lua print(require('nixCats').theBestCat)
      };
    };
  };
<
You can require('nixCats') for the set you define here in your lua
It returns a lua table of the same format.

see :help `nixCats`

---------------------------------------------------------------------------------------
Flake Exports and Export options               *nixCats.flake.outputs.exports*

First, we define our packages.
We can use utils.mkPackages to do this. 
It allows us to choose a default package, and
then it also exports all of them by name to choose from separately.

Then we define our overlays, using utils.mkOverlay to do this for the same reason.
utils.mkOverlay also makes a default overlay, and then 1 overlay per package.

Then we define our dev shell. We simply use our nixCatsBuilder for that one.
>nix
  packages = utils.mkPackages nixCatsBuilder packageDefinitions "nixCats";

  overlays = utils.mkOverlays nixCatsBuilder packageDefinitions "nixCats";

  devShell = pkgs.mkShell {
    name = "nixCats-devShell";
    packages = [ (nixCatsBuilder "nixCats") ];
    inputsFrom = [ ];
    shellHook = ''
    '';
  };
<
Now for the required exports for nix integration options.

They allow you to always export all of the same customization options to new
flakes as the original one has, but for your own flake.

for information on how to use these options when importing your nixCats flake,
see :help `nixCats.installation_options`

They look like this:
>nix
  # To choose settings and categories from the flake that calls this flake.
  customPackager = baseBuilder self pkgs categoryDefinitions;

  # You may use these to modify some or all of your categoryDefinitions
  customBuilders = {
    fresh = baseBuilder;
    keepLua = baseBuilder self;
  };
  inherit utils;

  inherit otherOverlays;
  inherit categoryDefinitions;
  inherit packageDefinitions;

  nixosModules.default = utils.mkNixosModules {
    defaultPackageName = "nixCats";
    luaPath = "${self}";
    inherit nixpkgs inputs baseBuilder otherOverlays 
      pkgs categoryDefinitions packageDefinitions;
  };

  # and the same for home manager
  homeModule = utils.mkHomeModules {
    defaultPackageName = "nixCats";
    luaPath = "${self}";
    inherit nixpkgs inputs baseBuilder otherOverlays 
      pkgs categoryDefinitions packageDefinitions;
  };
<
First, <customPackager>. This would allow you to choose what
settings and categories you wanted in a flake that imports this flake,
without needing to redefine anything else.

Then <customBuilders>. These are just baseBuilder, exported both with and
without a lua path already supplied.
You could import the fresh builder and utils straight from nixCats, 
alowing you to be free of personally including the builder and nixCatsHelp directories,
allowing you to use those but otherwise have a fresh start.

Then <otherOverlays>. These are a list of all overlays 
that you imported that are not standardPluginOverlay.
You may use utils.mergeOverlayLists to incorporate overlays 
from other nixCats flakes without worrying about naming conflicts.
When making your flake you must follow
this format when creating your pkgs set.
This format is not very complex. The format is this.
1. Make a list called otherOverlays.
2. Put every overlay that isn't standardPluginOverlay in there.
3. when you add overlays to pkgs, 
    use ++ to add otherOverlays to a list containing
    the call to standardPluginOverlay.
This allows you to be able to export otherOverlays
at the end in the final outputs because it is separate.

Then <categoryDefinitions>
The function where you set up your categories in flake.nix
This allows importing flakes to do a lot less copy pasting.

Then <packageDefinitions>
The set where you chose categories and settings for each package.
This allows importing flakes to do a lot less copy pasting.

<mkNixosModules> {
    defaultPackageName = "nixCats";
    luaPath = "${self}";
    inherit nixpkgs inputs baseBuilder otherOverlays 
      pkgs categoryDefinitions packageDefinitions;
};
Pass this set into utils.mkNixosModules and choose a defaultPackageName.
It will create a nixos module that you can import in configuration.nix
and will provide all the same import options as the usual flake import would
provide. See :help `nixCats.flake.outputs.exports.mkNixosModules`

<mkHomeModules>
The same as mkNixosModules above, but for home manager.


Then last, the <utils> set, which we imported from ./builder/utils.nix

In total, the <utils> set contains 8 functions

First, the ones mentioned above.

<mkPackages> finalBuilder: packageDefinitions: defaultName:
makes each package and also a default one

<mkOverlays> finalBuilder: packageDefinitions: defaultName:
makes an overlay for each package and also a default one

<standardPluginOverlay> inputs:
allows for inputs named plugins-something to be
turned into an overlay containing them as plugins automatically

In addition to those, there is also 5 convenience functions:

<mergeCatDefs> oldCats: newCats:
for merging category definitions,
will recursively update up to the first thing not an attrset

<mergeOverlayLists> oldOverlist: newOverlist: self: super: let
for merging lists of overlays like those in otherOverlays in a way 
that updates to avoid naming conflicts between overlays in different nixCats flakes imported.

<mkDefaultOverlay> finalBuilder: defaultName:
<mkExtraOverlays> finalBuilder: packageDefinitions:
which when combined with // make up mkOverlays

<mkMultiOverlay> finalBuilder: packageDefinitions: importName: namesIncList:
Instead of taking a name, it takes an importName and a list of names.
It will output them in an overlay accessible by pkgs.${importName}.${name}


---------------------------------------------------------------------------------------
Nix OS Module                     *nixCats.flake.outputs.exports.mkNixosModules*
                                  *nixCats.flake.outputs.exports.mkHomeModules*

We create the module by exporting the following in our flake outputs.

<mkNixosModules> {
    defaultPackageName = "nixCats";
    luaPath = "${self}";
    inherit nixpkgs inputs baseBuilder otherOverlays 
      pkgs categoryDefinitions packageDefinitions;
};

<mkHomeModules> {
    defaultPackageName = "nixCats";
    luaPath = "${self}";
    inherit nixpkgs inputs baseBuilder otherOverlays 
      pkgs categoryDefinitions packageDefinitions;
};

utils.mkNixosModules exports a nixos module with the following options,
and utils.mkHomeModules exports a home-manager module with the SAME EXACT options
as the nixos module has for system, but for the user managed by home-manager.

>nix
  options = with nixpkgs.lib; {

    # Set these with ${defaultPackageName} in your configuration.nix
    ${defaultPackageName} = {

      enable = mkOption {
        default = false;
        type = types.bool;
        description = "Enable ${defaultPackageName}";
      };
      packageName = mkOption {
        default = "${defaultPackageName}";
        type = types.str;
        description = ''
          The name of the package to be built from packageDefinitions.
          If using BOTH custom settings and categories, this can be arbitrary
        '';
        example = ''${defaultPackageName}'';
      };
      luaPath = mkOption {
        default = luaPath;
        type = types.str;
        description = ''
          The path to your nvim config directory in the store.
          In the base nixCats flake, this is "''${self}".
        '';
        example = ''"''${self}/systemLuaConfig"'';
      };
      settings = mkOption {
        default = packageDefinitions.${config.${defaultPackageName}.packageName}.settings or {};
        type = (types.attrsOf types.anything);
        description = "You may optionally provide your own settings set for packageDefinitions";
        example = ''
          {
            wrapRc = true;
            configDirName = "nixCats-nvim";
            viAlias = false;
            vimAlias = true;
            # nvimSRC = inputs.neovim;
          }
        '';
      };
      categories = mkOption {
        default = packageDefinitions.${config.${defaultPackageName}.packageName}.categories or {};
        type = (types.attrsOf types.anything);
        description = "You may optionally provide your own category set for packageDefinitions";
        example = ''
          {
            generalBuildInputs = true;
            markdown = true;
            gitPlugins = true;
            general = true;
            custom = true;
            neonixdev = true;
            debug = false;
            test = true;
            lspDebugMode = false;
            themer = true;
            colorscheme = "onedark";
          }
        '';
      };
      addOverlays = mkOption {
        default = [];
        type = (types.listOf types.anything);
        description = ''A list of overlays to make available to categoryDefinitions'';
        example = ''
          [ (self: super: { vimPlugins = { pluginDerivationName = pluginDerivation; }; }) ]
        '';
      };
      addInputs = mkOption {
        default = {};
        type = (types.attrsOf types.anything);
        description = ''
          A set of flake inputs to make available to 
          standardPluginOverlay and categoryDefinitions
        '';
        example = ''the inputs set of a flake'';
      };
      pkgsAdditions = mkOption {
        default = {};
        type = (types.attrsOf types.anything);
        description = ''things to add to pkgs outside of system and overlays'';
        example = ''{ config.allowUnfree = true; }'';
      };
      categoryDefinitions = {
        replace = mkOption {
          default = null;
          type = types.nullOr (types.functionTo (types.attrsOf types.anything));
          description = ''
            Takes a function that receives the package definition set of this package
            and returns a set of categoryDefinitions,
            just like :help nixCats.flake.outputs.categories
            Will replace the categoryDefinitions of the flake with this value.
          '';
          example = ''
            # see :help nixCats.flake.outputs.categories
            categoryDefinitions = packageDef: { }
          '';
        };
        merge = mkOption {
          default = null;
          type = types.nullOr (types.functionTo (types.attrsOf types.anything));
          description = ''
            Takes a function that receives the package definition set of this package
            and returns a set of categoryDefinitions,
            just like :help nixCats.flake.outputs.categories
            Will merge the categoryDefinitions of the flake with this value,
            recursively updating all non-attrset values,
            such as replacing old category lists with ones defined here.
          '';
          example = ''
            # see :help nixCats.flake.outputs.categories
            categoryDefinitions = packageDef: { }
          '';
        };
      };

      # Set these with ${defaultPackageName}.users.<username>
      # these options are only present for nixosModules
      # for home-manager, it only manages 1 user per home config,
      # so it has only the options above, which will apply to that user.
      users = mkOption {
        default = {};
        description = "same as system config but per user instead";
        type = with types; attrsOf (submodule {
          options = {
            # all the same options but per user....
            # Not here because its the same.
          };
        });
      };
    };

  };
<

I have condensed it here, but notice at the end it outputs
all the same options for each user when in a nixosModule as well?

---------------------------------------------------------------------------------------
vim:tw=78:ts=8:ft=help:norl:
