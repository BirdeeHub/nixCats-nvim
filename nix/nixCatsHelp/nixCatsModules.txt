===============================================================================
Nix OS Module                                    *nixCats.module*
                                  *nixCats.module.mkNixosModules*
                                   *nixCats.module.mkHomeModules*

We create the module by exporting the following in our flake outputs.

<mkNixosModules> {
    defaultPackageName = "nixCats";
    luaPath = "${./.}";
    inherit nixpkgs dependencyOverlays
      categoryDefinitions packageDefinitions;
};

<mkHomeModules> {
    defaultPackageName = "nixCats";
    luaPath = "${./.}";
    inherit nixpkgs dependencyOverlays
      categoryDefinitions packageDefinitions;
};

where dependencyOverlays is a set of system names
with lists of overlays in each item. Such that
the lists would be accessed via dependencyOverlays.${system}

If you do not have a luaPath, you may pass it a keepLua builder.
utils.mkNixosModules exports a nixos module with the following options,
and utils.mkHomeModules exports a home-manager module with the SAME EXACT options
as the nixos module has for system, but for the user managed by home-manager.

IMPORTANT
By default, the module inherits your system's pkgs object,
and its overlays. If you use stable channel for your system,
consider passing an `inputs.nixpkgs-unstable` from your inputs
to the `nixpkgs_version` module option.
It will still inherit your system overlays,
but your system will not inherit overlays from nixCats.

>nix
  options = with nixpkgs.lib; {

    # Set these with ${defaultPackageName} in your configuration.nix
    ${defaultPackageName} = {

      nixpkgs_version = mkOption {
        default = null;
        type = types.nullOr (types.anything);
        description = ''
          a different nixpkgs import to use. By default will use the one from the flake.
        '';
        example = ''
          nixpkgs_version = inputs.nixpkgs
        '';
      };

      addOverlays = mkOption {
        default = [];
        type = (types.listOf types.anything);
        description = ''
          A list of overlays to make available to nixCats but not to your system.
          Will have access to system overlays regardless of this setting.
        '';
        example = (lib.literalExpression ''
          addOverlays = [ (self: super: { vimPlugins = { pluginDerivationName = pluginDerivation; }; }) ]
        '');
      };

      # the above 2 are the only ones not also available at
      # a per-user level in the nixos system module.

      enable = mkOption {
        default = false;
        type = types.bool;
        description = "Enable ${defaultPackageName}";
      };

      luaPath = mkOption {
        default = luaPath;
        type = types.str;
        description = (lib.literalExpression ''
          The path to your nvim config directory in the store.
          In the base nixCats flake, this is "${./.}".
        '');
        example = (lib.literalExpression "${./.}/userLuaConfig");
      };

      packageNames = mkOption {
        default = [ "${defaultPackageName}" ];
        type = (types.listOf types.str);
        description = ''A list of packages from packageDefinitions to include'';
        example = ''
          packageNames = [ "nixCats" ]
        '';
      };

      categoryDefinitions = {
        replace = mkOption {
          default = null;
          type = types.nullOr (types.functionTo (types.attrsOf types.anything));
          description = (lib.literalExpression ''
            Takes a function that receives the package definition set of this package
            and returns a set of categoryDefinitions,
            just like :help nixCats.flake.outputs.categories
            you should use ${pkgs.system} provided in the packageDef set
            to access system specific items.
            Will replace the categoryDefinitions of the flake with this value.
          '');
          example = ''
            # see :help nixCats.flake.outputs.categories
            categoryDefinitions.replace = { pkgs, settings, categories, name, ... }@packageDef: { }
          '';
        };
        merge = mkOption {
          default = null;
          type = types.nullOr (types.functionTo (types.attrsOf types.anything));
          description = ''
            Takes a function that receives the package definition set of this package
            and returns a set of categoryDefinitions,
            just like :help nixCats.flake.outputs.categories
            Will merge the categoryDefinitions of the flake with this value,
            recursively updating all non-attrset values,
            such as replacing old category lists with ones defined here.
          '';
          example = ''
            # see :help nixCats.flake.outputs.categories
            categoryDefinitions.merge = { pkgs, settings, categories, name, ... }@packageDef: { }
          '';
        };
      };

      packages = mkOption {
        default = null;
        description = ''
          VERY IMPORTANT when setting aliases for each package,
          they must not be the same as ANY other neovim package for that user.
          YOU MAY NOT ALIAS TO NVIM ITSELF
          It will cause a build conflict.
          again, YOU MAY NOT ALIAS TO NVIM ITSELF

          You also cannot install nixCats via
          multiple nixCats modules from different repos per user.
          This should not be an issue as a single module can output multiple packages.

          You can have as many nixCats installed per user as you want,
          as long as you obey those rules.
          This is a big step up from only being able to have 1 neovim
          at all per user, so excuse me for the inconvenience.

          for information on the values you may return,
          see :help nixCats.flake.outputs.settings
          and :help nixCats.flake.outputs.categories
          https://github.com/BirdeeHub/nixCats-nvim/blob/main/nix/nixCatsHelp/nixCatsFlake.txt
        '';
        type = with types; nullOr (attrsOf (functionTo (attrsOf anything)));
        example = ''
          nixCats.packages = { 
            nixCats = { pkgs, ... }: {
              settings = {
                wrapRc = true;
                configDirName = "nixCats-nvim";
                # nvimSRC = inputs.neovim;
                aliases = [ "vim" "nixCats" ];
              };
              categories = {
                generalBuildInputs = true;
                markdown = true;
                gitPlugins = true;
                general = true;
                custom = true;
                neonixdev = true;
                debug = false;
                test = true;
                lspDebugMode = false;
                themer = true;
                colorscheme = "onedark";
              };
            };
          }
        '';
      };

      users = mkOption {
        default = {};
        description = ''
          same as system config but per user instead
          and without addOverlays or nixpkgs_version
        '';
        type = with types; attrsOf (submodule {
          options = {
            enable = mkOption {
              default = false;
              type = types.bool;
              description = "Enable ${defaultPackageName}";
            };
            # the same options but per user....
            # Not shown here because its the same.
          };
        });
      };
    };

  };
<

I have condensed it here, but notice at the end it outputs
all the same options for each user when in a nixosModule as well?

in addition, there are some config values that can be used to reference the
configs made in the module
>nix
  config.${defaultPackageName}.out.packages.<PACKAGE_NAME>
<

and if using the nixos module there is ALSO
>nix
  config.${defaultPackageName}.out.users.<USER_NAME>.packages.<PACKAGE_NAME>
<
---------------------------------------------------------------------------------------
vim:tw=78:ts=8:ft=help:norl:
