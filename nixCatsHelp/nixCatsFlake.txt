=======================================================================================
Flake Help                                                      *nixCats.flake*

A Lua-natic's neovim flake, with extra cats! nixCats!

This is the documentation for the flake itself.
This flake uses nix for importing plugins, lsps, dependencies, and more,
in place of usual nvim package managers such as packer, lazy or mason.

Everything else is done in a regular lua config style.
Download in flake.nix and then, simply pretend the root of the flake 
is the root of your Lua config. 

1 exception, when wrapRc = true, 
`stdpath('config')` will still point to ~/.config/<configDirName>.
But your lua config will be in the store.
This is ok, because most of the reason for a plugin to use
it would be to find something outside the directory. 
Inside is mostly handled by vim.
You can use debug.getinfo(1, "S").source:sub(2) or something similar 
to get current script directory for your uses, if ever necessary.
Keep in mind they will be read-only and theres definitely a more
in built vim way to do it.

*******************************************************
One IMPORTANT note:
When editing the files within the flake directory,
nix will not package a new file if it isn't staged in git.
run git add before rebuilding it whenever adding a new file.
Using wrapRc = true would mean this also applies to lua files.
In fact, when wrapRc = true, even changes within a lua file
will not be reflected unless you run git add.
*******************************************************

Related:
For detecting what was included by 
the flake in your Lua, see:
:help `nixCats`

=======================================================================================
Flake Inputs:                                            *nixCats.flake.inputs*

If they dont have an extra build step, 
name the plugins you import from github 
plugins-somepluginname 
They will be processed automatically into plugins by the default overlay.

If the plugin has a dot in it's name, you should name it something else.
The name here only affects the filename of the overall plugin, and should
only effect things like packadd. Usually I would replace it with - or _
You will then add it to categoryDefinitions later with the NEW name.

If they have a build step or are not a plugin, 
i.e. an lsp, dont name them in that format.

If they are on nixpkgs, you dont necessarily need to put them in inputs,
because you will be able to access them through pkgs.vimPlugins variable later.

Most plugins will not require you to use this section due to being on nixpkgs.
But you may still use it to pin the plugin to a specific version.

Context for later:

If they have a build step, you will deal with them in overlays/customBuildsOverlay.nix
then import them into a category of the builder. 
(assuming nixpkgs hasn't already done it!!)

If they are not a plugin:
You will import them into a category of the builder under lspsAndDeps, 
unless they are for build time, then put them under propagatedBuildInputs

=======================================================================================
Flake Outputs Introduction                              *nixCats.flake.outputs*

With our inputs to our flake taken care of:

First, we call flake utils to get system variable for all default systems.
Then we import our nixCats utils, so that we can access things
like overlay <1>, utils.standardPluginOverlay.

                                               *nixCats.flake.outputs.overlays*
Then, we define our overlays.
We have 2 main overlays to discuss.

<1>
-- The first is utils.standardPluginOverlay:
You do not need to edit it to use it.

It takes all the inputs named in the format
'plugins-somepluginname' and makes them into plugins. 
If the plugin doesn't have a build step,
and it wasnt on nixpkgs, then use this method.
Access them to add them to a category of the builder function 
with 'pkgs.neovimPlugins.somepluginname'

<2>
-- The second is overlays/customBuildsOverlay.nix:

If you need to interact with one of these overlays, it will be this one.
You should not need to do it much. 
overlays/default.nix imports this overlay and any others like it.
see :help `nixCats.flake.nixperts.overlays`

It is used for defining plugins with build steps that 
were not well handled by nixpkgs.
It is passed flake inputs, and super is pkgs.
Define the things within the file. 
Then, access plugins defined there later 
with 'pkgs.nixCatsBuilds.somepluginname'

If you decide you wish to split your customBuildsOverlay up, 
see :help `nixCats.flake.nixperts.overlays`
or look at the overlays/default.nix file.

<pkgs>
-- After the overlays we wish to include are all defined:

We now generate the pkgs set that contains all the nixpkgs and overlay packages, 
and the system variable from flake-utils. If you imported any flakes with
overlays, add their overlay here as well.

pkgs will contain all our plugins and programs we will need from this point on.
with the occasional exception of a flake that has no overlays, which you just
add to a category directly.

---------------------------------------------------------------------------------------
Neovim Builder Creation:                        *nixCats.flake.outputs.builder*

Now we define our builder function.
We do this by importing ./builder/default.nix which is
a function that takes 6 arguments.
Right now we are going to call it with just the first 5 of them. This will
leave us with a function that takes 1 argument.
That argument is the name of the neovim package to be packaged.

1. The path to the help directory so that it is always included in outputs of
     this flake.
2. The path to the lua to include (in the flake, we use the self variable to get
     this path and wrap the lua when wrapRc = true)
3. The pkgs set so that it can use it for making its own derivations.
4. our function that takes a name and returns a set of categoryDefinitions.
5. our set of packageDefinitions see: `nixCats.flake.outputs.packageDefinitions`

It is now a function that takes a name, and returns your chosen neovim package.
>nix
      baseBuilder = import ./builder "${self}/nixCatsHelp";
      nixCatsBuilder = baseBuilder self pkgs
        # notice how it doesn't care these 2 are defined lower in the file?
        categoryDefinitions packageDefinitions;
<
      # We defined baseBuilder separately 
      # so that we can easily export it later.
      # this will ensure that other flakes that import 
      # only this function from our flake may still access the help.

---------------------------------------------------------------------------------------
                                            *nixCats.flake.outputs.categories*
Then we define what is in our categories!
This section is a function that takes the name of the package 
it was packaged with as an argument. The builder will call it.
This allows categoryDefinitions to access their packages categories and settings.
You may do this by using: >nix
    packageDefinitions.${name}
<
These are the things you can return:
>nix
  categoryDefinitions = name: {
<
<propagatedBuildInputs> 
  a flexible set of categories, each containing a list of 
  internal BUILD TIME dependencies. Will also be available to the devShell.

<lspsAndRuntimeDeps>
  a flexible set of categories, each containing a list of LSP's or 
  other internal runtime dependencies such as ctags or debuggers
  these are available to the PATH while within the neovim program.
  this includes the neovim terminal.

<startupPlugins>
  a flexible set of categories, each containing a list of startup plugins.
  Startup plugins are loaded and can be required. 

<optionalPlugins>
  a flexible set of categories, each containing a list of optional plugins.
  Optional plugins need to be added with packadd before being required.

<environmentVariables>
  a flexible set of categories, each containing an ATTRIBUTE SET of 
  EnvironmentVariableName = "EnvironmentVariableValue";

<extraWrapperArgs>
  a flexible set of categories, each containing a list of 
  extra wrapper arguments.
  If you don't know what that is, see here:
github.com/NixOS/nixpkgs/blob/master/pkgs/build-support/setup-hooks/make-wrapper.sh

<extraLuaPackages>
  a flexible set of categories, each containing a list of FUNCTIONS 
  that return lists of extra Lua packages.
  These functions are the same thing that you would pass to lua.withPackages.

<extraPythonPackages> <extraPython3Packages> 
  TWO flexible sets of categories, one for python and the other for python3,
  each containing a list of FUNCTIONS that return lists of python packages.
  These functions are the same thing that you would pass to python.withPackages.

  <optionalLuaAdditions>* It can also take a lua string that can be run.
    Yes it can access nixCats.
    It is not the recommended way to create lua for this flake, 
    but it may be useful in some edge cases of editing flake imports 
    of other already configured setups following the nixCats format.
    Therefore, I have included this option.
}

how this function actually works is covered in 
:help `nixCats.flake.nixperts.nvimBuilder`
In essence, the contents of each set listed here are filtered
based on the packageDefinitions set you provide, 
where by including categoryname = true; you enable that category.
:help `nixCats.flake.outputs.packageDefinitions`

---------------------------------------------------------------------------------------
Settings Profiles:                             *nixCats.flake.outputs.settings*

These are the defaults:
>nix
  settings = {
    defaults = {
<
      # do you want to package the lua from this flake in the store?
      # or would you rather it just read it in your .config/<configDirName>?
      # nixCats and this help will work either way.
      # this value will also be included in nixCats.
>nix
      wrapRc = true;
<
      # What should the name of the folder within standard directories
      # i.e. .config, .local/share, .local/state, .cache, etc... be?
      # This option is very useful when you want 
      # to clone an unwrapped config straight to the .config dir.
      # see :help `$NVIM_APPNAME`
>nix
      configDirName = "nvim";

      # and the rest:
      viAlias = false;
      vimAlias = false;
      withNodeJs = false;
      withRuby = true;
      extraName = "";
      withPython3 = true;
    };
  };
<
If you wish to have something different, you may define some or all of these
options, in a set within the settings set to be included in the packaging section below.

---------------------------------------------------------------------------------------
Package Generation:                           *nixCats.flake.outputs.packageDefinitions*

generate packages by calling that builder function we just created.
Place them in the packageDefinitions set.

First, pick the set of settings you wish to include.

Then, pass it a set of named boolean values like this:
{ categoryname1 = true; categoryname2 = false; etc... }
False may be omitted. True may not be omitted.
Only true matters for what plugins will be added.

These categories are defined in the Builder function above 
by placing named lists of plugins in the flexible sets provided.
The category names are the names of those lists. 
Add a new list, then enable the category here.

If you have categories with the same name in 
multiple different sets outlined above in the builder,
all plugins in those categories will be
included when you set "thatname = true;" here.
hence, general = true; will include the general lspsAndDeps category,
as well as the general startupPlugins category.

an example package definition:
>nix
  packageDefinitions = {
    nixCats = { 
      setting = settings.nixCats;
      categories = {
        custom = true;
        gitPlugins = true;
        general = true;
        neonixdev = true;

        # this does not have an associated category of plugins, 
        # but lua can still check for it
        lspDebugMode = false;

        # you could also pass something else and it calls 
        # builtins.toString on it and passes it in as a string
        theBestCat = "says meow!!!";
        # maybe you need to pass a port or path in or something idk.
        # you could :lua print(require('nixCats').theBestCat)
      };
    };
  };
<
You can require('nixCats') for the set you define here in your lua
It returns a lua table of the same format.

see :help `nixCats`

---------------------------------------------------------------------------------------
Flake Exports and Export options               *nixCats.flake.outputs.exports*

First, we define our packages.
We can use utils.mkPackages to do this. 
It allows us to choose a default package, and
then it also exports all of them by name to choose from separately.

Then we define our overlays, using utils.mkOverlay to do this for the same reason.
utils.mkOverlay also makes a default overlay, and then 1 overlay per package.

Then we define our dev shell. We simply use our nixCatsBuilder for this one.
>nix
  packages = utils.mkPackages nixCatsBuilder packageDefinitions "nixCats";

  overlays = utils.mkOverlays nixCatsBuilder packageDefinitions "nixCats";

  devShell = pkgs.mkShell {
    name = "nixCats-devShell";
    packages = [ (nixCatsBuilder "nixCats") ];
    inputsFrom = [ ];
    shellHook = ''
    '';
  };
<
Now for the required exports for nix integration options.

They allow you to always export all of the same customization options to new
flakes as the original one has, but for your own flake.

for information on how to use these options when importing your nixCats flake,
see :help `nixCats.installation_options`

They look like this:
>nix
  # To choose settings and categories from the flake that calls this flake.
  customPackager = baseBuilder self pkgs categoryDefinitions;

  # You may use these to modify some or all of your categoryDefinitions
  customBuilders = {
    fresh = baseBuilder;
    keepLua = baseBuilder self;
  };
  inherit utils;

  inherit otherOverlays;
  inherit categoryDefinitions;
  inherit packageDefinitions;
<

First, <customPackager>. This would allow you to choose what
settings and categories you wanted in a flake that imports this flake,
without needing to redefine anything else.

Then <customBuilders>. These are just baseBuilder, exported both with and
without a lua path already supplied.
You could import the fresh builder and utils straight from nixCats, 
alowing you to be free of personally including the builder and nixCatsHelp directories,
allowing you to use those but otherwise have a fresh start.

Then <otherOverlays>. These are a list of all overlays 
that you imported that are not standardPluginOverlay.
You may use utils.mergeOverlayLists to incorporate overlays 
from other nixCats flakes without worrying about naming conflicts.
When creating your flake, make sure to follow the format shown
in :help `nixCats.installation_options.advanced` 
when importing overlays to your pkgs set.
That format is not very complex. The format is this.
1. Make a list called otherOverlays.
2. Put every overlay that isn't standardPluginOverlay in there.
3. when you add overlays to pkgs, 
    use ++ to add otherOverlays to a list containing
    the call to standardPluginOverlay.
This allows you to be able to export otherOverlays
at the end in the final outputs because it is separate.

Then <categoryDefinitions>
The function where you set up your categories in flake.nix
This allows importing flakes to do a lot less copy pasting.

Then <packageDefinitions>
The set where you chose categories and settings for each package.
This allows importing flakes to do a lot less copy pasting.



Then last, the <utils> set, which we imported from ./builder/utils.nix

In total, the <utils> set contains 8 functions

First, the ones mentioned above.

<mkPackages> finalBuilder: packageDefinitions: defaultName:
makes each package and also a default one

<mkOverlays> finalBuilder: packageDefinitions: defaultName:
makes an overlay for each package and also a default one

<standardPluginOverlay> inputs:
allows for inputs named plugins-something to be
turned into an overlay containing them as plugins automatically

In addition to those, there is also 5 convenience functions:

<mergeCatDefs> pkgs: oldCats: newCats:
for merging category definitions,

<mergeOverlayLists> oldOverlist: newOverlist: self: super: let
for merging lists of overlays like those in otherOverlays in a way 
that updates to avoid naming conflicts between overlays in different nixCats flakes imported.

<mkDefaultOverlay> finalBuilder: defaultName:
<mkExtraOverlays> finalBuilder: packageDefinitions:
which when combined with // make up mkOverlays

<mkMultiOverlay> finalBuilder: packageDefinitions: importName: namesIncList:
Instead of taking a name, it takes an importName and a list of names.
It will output them in an overlay accessible by pkgs.${importName}.${name}


---------------------------------------------------------------------------------------
vim:tw=78:ts=8:ft=help:norl:
