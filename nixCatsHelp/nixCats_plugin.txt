=======================================================================================
NIX CATEGORIES                                                       *nixCats*

For help with the Nix flake files, see :help |nixCats.flake|.

*******************************************************
AN IMPORTANT NOTE:

<1> When editing the files within the flake directory,
Nix will not package a new file if it isn't staged in git.
run `git add` before rebuilding it whenever adding a new file.
Using `wrapRc = true` would mean this also applies to Lua files.
In fact, when `wrapRc = true`, even changes within a Lua file
will not be reflected unless you run `git add`.
*******************************************************

nixCats: returns category names included by Nix for this package

Use a dot-separated string to check if this Neovim was packaged with
a particular category included:
>lua
    if nixCats('lua.someSubcategory') then
        -- some stuff here
    end
<
Checking a category that is not present rather than false,
will still return false from this if statement because `nil` in Lua is "falsey".
That is, if Nix was not a category you included a value true or false for,
it would evaluate as if it was false.
If your category has an illegal Lua name you may instead use this syntax
>lua
    nixCats { 'attr-set', "path", "to", [[valu.e'!#$@]] }
<
nixCats command will return the nearest parent category value, unless the nearest
parent is a table, in which case that means a different subcategory
was enabled but this one was not.
In that case it will try to find the next value, fail, and return nil.
If the item you are checking is a table,
`if nixCats('the.table') then print("true") end`
will print true, and `nixCats('the.table')` will return the table.

The nixCats global function is an alias for require('nixCats').get()

The nixCats "plugin" is just some tables and a get function.
It is generated by the flake, and the table is
the same one you provided to choose what
categories are included in each package in the flake.nix file.

However it also adds a few values for convenience.
  nixCats_packageName
  nixCats_config_location
  nixCats_wrapRc

Because it adds these to nixCats, do not use them as
a category name in your package definition (example package definition below).
They will be replaced.

If in your flake, your package definition looked like this:
  see :help |nixCats.flake.outputs.packageDefinitions|
>nix
  packageDefinitions = {
    nixCats = { pkgs, ... }@misc: {
      settings = settings.nixCats; 
      categories = {
        generalBuildInputs = true;
        markdown = true;
        general.vimPlugins = true;
        general.gitPlugins = true;
        custom = true;
        neonixdev = true;
        test = {
          subtest1 = true;
        };
        debug = false;
        # This does not have an associated category of plugins,
        # but Lua can still check for it.
        lspDebugMode = false;
        # By default, we don't want lazy.nvim.
        # We could omit this for the same effect.
        lazy = false;
        # You could also pass something else:
        themer = true;
        colorscheme = "onedark";
        theBestCat = "says meow!!";
        theWorstCat = {
          thing'1 = [ "MEOW" "HISSS" ];
          thing2 = [
            {
              thing3 = [ "give" "treat" ];
            }
            "I LOVE KEYBOARDS"
          ];
          thing4 = "couch is for scratching";
        };
        # see :help nixCats
      };
    };
  };
<
Using:
>vim
    :lua print(vim.inspect(require('nixCats').cats))
    or
    :lua print(vim.inspect(nixCats.cats))
    or
    :NixCats
    or
    :NixCats cats
<
will return something like this:
>lua
  {
    colorscheme = "onedark",
    custom = true,
    debug = false,
    general = {
      gitPlugins = true,
      vimPlugins = true
    },
    generalBuildInputs = true,
    lazy = false,
    lspDebugMode = false,
    markdown = true,
    neonixdev = true,
    nixCats_packageName = "nixCats",
    nixCats_config_location = "/nix/store/fazkaci8bravyly4xahs0b69r1xxj4i3-nixCats-special-rtp-entry-LuaConfig",
    nixCats_wrapRc = true,
    test = {
      subtest1 = true
    },
    theBestCat = "says meow!!",
    theWorstCat = {
      ["thing'1"] = { "MEOW", "HISSS" },
      thing2 = { {
          thing3 = { "give", "treat" }
        }, "I LOVE KEYBOARDS" },
      thing4 = "couch is for scratching"
    },
    themer = true
  }
<
Note: it also accepts other things.
lists will become arrays
sets will become tables
null will become nil
numbers will remain numbers
derivations will become store paths

everything that isn't true, false, null,
a list, or a set becomes a Lua string.
it uses "[[${builtins.toString value}]]"
in order to achieve this.
It will throw an error if you pass an uncalled function.

If theBestCat says meow, and you use this syntax,
>lua
    if nixCats('theBestCat') then
      print("true")
    end
<
theBestCat will evaluate as true if 
it contains something that isnt false (or nil).
>lua
    if nixCats('theBestCat') == true then
      print("true")
    else
      print("false")
    end
<
However, this one will print false.

Regardless, dependencies included under vocal cats 
will not be included. So don't go changing all true 
values to "meow" it wont work. 

Only categories with the boolean value true are included
from the flake.

Use this fact as you wish.
You could use it to pass information like port numbers or paths
Or whatever else you want.

In addition to `nixCats.cats`, nixCats also contains other info.
>lua
  ---@class nixCats.main
  ---
  ---See :h nixCats.flake.outputs.packageDefinitions
  ---Function form will return vim.tbl_get for the attrpath
  ---@field cats table|fun(attrpath: string|string[]): any
  ---
  ---See :h nixCats.flake.outputs.settings
  ---Function form will return vim.tbl_get for the attrpath
  ---@field settings table|fun(attrpath: string|string[]): any
  ---
  ---See :h nixCats.flake.outputs.packageDefinitions
  ---Function form will return vim.tbl_get for the attrpath
  ---@field extra table|fun(attrpath: string|string[]): any
  ---
  ---Contains the final set of plugins added for this package
  ---Function form will return vim.tbl_get for the attrpath
  ---@field pawsible table|fun(attrpath: string|string[]): any
  ---
  ---Contains all the defined categories that you COULD enable from nix
  ---Function form will return vim.tbl_get for the attrpath
  ---@field petShop table|fun(attrpath: string|string[]): any
  ---
  ---The path to your configuration for the package
  ---@field configDir string
  ---
  ---Path to the nixCats wrapper script that launches nvim
  ---@field packageBinPath string
  ---
  ---The path to the packpath directory with all your plugins from nix
  ---Useful for things such as vim-startuptime which must reference the wrapper's actual path
  ---@field vimPackDir string
  ---
  ---The path to the nixCats plugin
  ---@field nixCatsPath string
  ---
  ---internal: this creates the nixCats global commands
  ---@field addGlobals fun() 
  ---
  ---:h nixCats
  ---This function will return the nearest parent category value, unless the nearest
  ---parent is a table, in which case that means a different subcategory
  ---was enabled but this one was not. In that case it returns nil.
  ---@field get fun(category: string|string[]): any

  ---The main nixCats("cat.name") function
  ---It is an alias for `nixCats.get("cat.name")`
  ---@alias nixCats nixCats.main | fun(category: string|string[]): any
<
All of the above may be accessed in lua via
`nixCats.<item>`, or `require('nixCats').<item>`, or `:NixCats` <item>,
and the `:NixCats` user command also
has the `cat` subcommand to preview the value from `nixCats("catname")`
You can view these for debugging purposes with `:NixCats settings` and
`:NixCats pawsible` user commands.

Everything provided by the nixCats plugin can be printed
for debugging purposes via the `:NixCats` user command.
e.g. `:NixCats cats` shown above will print the `nixCats.cats` table.

Using `:NixCats cat path.to.value` or `:NixCats cat path to value`
will print the value of `nixCats('path.to.value')

The debug command by default will create
a popup window to display the information.

If you don't like that, or are using neovim embedded
in another application without buffer or window support,
(such as vscode), you may set
`vim.g.nixcats_debug_ui = false`
which will cause it to do a simple `print(vim.inspect(value))` instead.
Or, you can simply print them yourself!
`print(vim.inspect(nixCats.cats))`

In addition, you may also access these items directly within vimscript! >vim
  v:lua.require('nixCats').cats
<
There are some helper functions included in the plugin that call that for you,
but if you are going to use vimscript in neovim, knowing how to call lua is
important. So, I showed the general way first.

`GetNixCat(value)` is equivalent to the `nixCats(value)` command in Lua.
`GetNixSettings()` is `require('nixCats').settings`
`GetNixPawsible()` is `require('nixCats').pawsible`
`GetNixExtra()` is `require('nixCats').extra`
`GetNixCats()` is `require('nixCats').cats`

----------------------------------------------------------------------------------------
vim:tw=78:ts=8:ft=help:norl:
