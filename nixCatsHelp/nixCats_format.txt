=======================================================================================
Flake Help                                                      *nixCats.flake*

A Lua-natic's Neovim flake, with extra cats! nixCats!

This is the documentation for the flake itself.
This flake uses Nix for importing plugins, LSPs, dependencies, and more,
in place of usual nvim package managers such as packer, lazy or Mason.

Everything else is done in a regular Lua config style.
Download in flake.nix and then, simply pretend the root of the flake 
is the root of your Lua config. 

*******************************************************
AN IMPORTANT NOTE:

<1> When editing the files within the flake directory,
Nix will not package a new file if it isn't staged in git.
run git add before rebuilding it whenever adding a new file.
Using `wrapRc = true` would mean this also applies to Lua files.
Only tracked files will recieve their updates when
rebuilt without git add being ran first. New files need to be added.
*******************************************************

Related:
For detecting what was included by 
the flake in your Lua, see:
:help |nixCats|

`stdpath('config')` will still point to `~/.config/<configDirName>`.
But your Lua config will be in the store.
This is okay, because most of the reason for a plugin to use
it would be to write to it, and we cant write to store paths anyway. 
You could use `require('nixCats').configDir`,
or `nixCats('nixCats_config_location')`
to get current config directory for your uses, if ever necessary.
It will be present and correct regardless of settings.

However if you did not use Nix at all and did not run the setup
function, of course the nixCats plugin wont be there to ask.

The setup function from `require('nixCatsUtils').setup`
will provide a mock nixCats plugin with SOME values
and empty tables to prevent accidental indexing errors.
You could instead do `require('nixCatsUtils').isNixCats` to default to
`vim.fn.stdpath('config')` if all you wanted was this path though.

Keep in mind they will be read-only if in the store!

=======================================================================================
Flake Inputs:                                            *nixCats.flake.inputs*

If a plugin does not have an extra build step, and are not on nixpkgs,
you may use this format to import them, replacing the fields marked with <>
>nix
    "plugins-<pluginName>" = {
      url = "github:<userName>/<repositoryName>";
      flake = false;
    };
<
More info on flake url syntax at:
https://nixos.org/manual/nix/stable/command-ref/new-cli/nix3-flake.html#examples
You may also use this syntax to pin the version of a plugin regardless of whether
you ran `nix flake update` or not.
You may choose the directory, branch, commit, tag, or even directory
imported.

All inputs named in the `plugins-<pluginName>` format will be added to pkgs
at `pkgs.neovimPlugins.<pluginName>` for you to add to your configuration.

If the plugin has a dot `.` character in it's name, you should name it something else
because . is not a valid character in an identifier in Nix.

The name here only affects the filename of the overall plugin, and should
only affect things like vim.cmd("packadd <filename>") that refer to
the actual filename of the plugin. Usually I would replace it with -
You will then add it to categoryDefinitions later with the NEW name.

If you use this method to import a plugin, and really dont
want to change the filename of the plugin when they have a
dot in their name, you may
swap the call to `(utils.standardPluginOverlay inputs)`
with `(utils.sanitizedPluginOverlay inputs)`
and then `plugins-plugin.name` would become `pkgs.neovimPlugins.plugin-name`
but Neovim would see it as `vim.cmd("packadd plugin.name")` still

If they have a build step or are not a plugin, 
i.e. an LSP, or if they are a plugin from a flake,
dont name them in that format.
If they are a plugin from a flake, they can be added directly,
or they may be added as an overlay if offered.
If they are anything else they arent a plugin at all and obviously
should not be added as a plugin via plugins-<pluginName>

If they are on nixpkgs, you dont need to put them in inputs,
because you will be able to access them through pkgs.vimPlugins variable.
Most plugins will not require you to use the inputs section due to being on nixpkgs.
But you may still use it to pin the plugin to a specific version.

If you decided not to use utils.sanitizedPluginOverlay
and wanted to do it with utils.standardPluginOverlay:
If in your inputs you had:
>nix
  "plugins-<plugin-name>" = {
    url = "github:<userName>/<repository.name>";
    flake = false;
  };
<
Where you put plugins in your categoryDefinitions, instead of:
>nix
  pkgs.neovimPlugins.<plugin-name>
<
You could put this:
>nix
  { name = "<plugin.name>"; plugin = pkgs.neovimPlugins.<plugin-name>; }
<
You can also override them instead of (or before/during) the above:
>nix
  (pkgs.neovimPlugins.<plugin-name>.overrideAttrs { pname = "<plugin.name>"; })
<
overrideAttrs can be used for a lot more than just fixing the name of the
imported plugin. See:
https://ryantm.github.io/nixpkgs/using/overrides/

If they have a build step and are not on nixpkgs,
you will deal with them in overlays/customBuildsOverlay.nix
then import them into a category of the builder. 
Alternatively you may use overrideAttrs as mentioned above instead of an
overlay for these sorts of packages, but this would possibly get messy if the
build step were complex.

=======================================================================================
Flake Outputs Introduction                              *nixCats.flake.outputs*

With our inputs to our flake taken care of:
First, we take care of importing our utils set from nixCats.
The reason we are doing this now, is so that it can be defined outside of
the utils.eachSystem function, and thus we can export it
without having to include a system variable when we import it somewhere else.

We also define our luaPath, which is the path to be loaded into the store as
your new Neovim config directory. (see :help |'rtp'| for the directories
available for you to use!)

We also define our extra_pkg_config, which is used when initializing the
nixpkgs instance that will build your Neovim! It's the same one from
>nix
  pkgs = import nixpkgs { inherit system; overlays = []; config = {}; }
<
That is,
>nix
  outputs = { self, nixpkgs, ... }@inputs: let
    # In the templates, this is inherit (inputs.nixCats) utils;
    inherit (inputs.nixCats) utils;
    # path the the store path to be loaded as Neovim config directory
    luaPath = "${./.}";
    # used when initializing the nixpkgs instance
    extra_pkg_config = {
      # allowUnfree = true;
    };
<
                                           *nixCats.flake.outputs.getOverlays*
>nix
Managing the system variable in combination with overlays
can be one of the hardest parts of flake usage.
This flake resolves our pkgs instance for Neovim itself to help with this,
and takes care of passing the correct pkgs instance
to the relevant locations later for use in defining your dependencies.

>nix
  dependencyOverlays = (import ./overlays inputs) ++ [
    (utils.standardPluginOverlay inputs)
    inputs.neorg-overlay.overlays.default
    inputs.lz-n.overlays.default

    # No overlays SHOULD be exported requiring the ${system} variable to access.
    # However, some are (such as codeium, a free ai plugin)

    # when other people mess up their overlays
    # by wrapping them with flake-utils,
    # you may instead call this function on their overlay.
    # it will check if it has the system in it.
    # if so, it will call the function with the system
    # and return the desired overlay
    (utils.fixSystemizedOverlay inputs.codeium.overlays
      (system: inputs.codeium.overlays.${system}.default)
    )
  ];
<

                                               *nixCats.flake.outputs.overlays*
`utils.standardPluginOverlay`
Usage of this function to create an overlay is described in:
:h |nixCats.flake.inputs|
along with its friend, `utils.sanitizedPluginOverlay`

It takes all the inputs named in the format
`plugins-somepluginname` and makes them into plugins. 
Access them to add them to a category of the builder function 
with `pkgs.neovimPlugins.somepluginname`

If the plugin doesn't have a build step,
and it wasnt on nixpkgs, then use this method.

If the plugin does have a build step and isn't on nixpkgs,
then you can either make your own overlay from scratch,
or you can call overrideAttrs on the generated plugin
to add the required items to it.
more info at :h |nixCats.flake.inputs|

If you decide you wish to split your customBuildsOverlay up, 
see :help |nixCats.flake.nixperts.overlays|
or look at the overlays/default.nix file for advice on how to do that.

---------------------------------------------------------------------------------------
                                            *nixCats.flake.outputs.categories*
Then we define what is in our categories!
This section is a function that takes the package definition for this
particular package as an argument.
The builder will call it with that argument, you may use it.
This allows categoryDefinitions to access their packages categories and settings,
which allows categoryDefinitions to be much more dynamic.

It also gets `mkPlugin = name: src:` as an argument. `mkPlugin` takes a name,
and then a src which is any flake input or fetched drv,
and it returns a nvim plugin that can be further overriden via overrideAttrs if desired.
There is an overlay to do this automatically from flake inputs, mentioned
above. But sometimes it can be advantageous to do one of them individually.

It also recieves a `mkNvimPlugin = src: name:` which does the same thing, but
with the arguments the wrong way around.
It is still present for backwards compatibility.

These are the things you can return:
>nix
  categoryDefinitions = { pkgs, settings, categories, extra, name, mkPlugin, mkNvimPlugin, ... }@packageDef: {
<
<startupPlugins>
  a flexible set of categories, each containing startup plugins.
  Startup plugins are loaded and can be required. 

<optionalPlugins>
  a flexible set of categories, each containing optional plugins.
  Optional plugins need to be added with packadd before being required.
  Use :NixCats pawsible to see the names to use for packadd

<lspsAndRuntimeDeps>
  a flexible set of categories, each containing LSPs or
  other internal runtime dependencies such as ctags or debuggers
  these are available to the PATH while within the Neovim program.
  this includes the Neovim terminal.

<sharedLibraries>
  a flexible set of categories, each containing a derivation for
  a runtime shared library. Will be prepended to the LD_LIBRARY_PATH variable.

<environmentVariables>
  a flexible set of categories, each containing an ATTRIBUTE SET of 
  EnvironmentVariableName = "EnvironmentVariableValue";

<wrapperArgs>
  a flexible set of categories, each containing escaped lists of wrapper arguments. >nix
    wrapperArgs = {
      yourCategory = [
        [ "--set" "MYVAR" "test value" ]
      ];
      another = [
        "--suffix"
        "PATH"
        "${pkgs.lib.makeBinPath [ pkgs.something ]}" # <- lspsAndRuntimeDeps does this
      ];
    };
<  If you don't know what that is, see here:
https://github.com/NixOS/nixpkgs/blob/master/pkgs/build-support/setup-hooks/make-wrapper.sh

<extraWrapperArgs>
  a flexible set of categories, each containing unescaped wrapper arguments. >nix
    extraWrapperArgs = {
      yourCategory = [
        "--set MYVAR 'test value'"
      ];
    };
<
<extraLuaPackages>
  a flexible set of categories, each containing FUNCTIONS 
  that return lists of extra Lua packages.
  These functions are the same thing that you would pass to lua.withPackages.
  Is used to populate $LUA_PATH and $LUA_CPATH

<optionalLuaPreInit>
  a flexible set of categories, each containing a list of lua strings,
  or a LIST of sets containing a priority and a string of the format:
  `catname = [ "require('athing')" { config = "require('something')"; priority = 150; } ];`
  (150 is default priority)
  These will be ran before sourcing your init.lua
  It is not the recommended way to create Lua for this flake,
  but it may be useful in editing flake imports 
  of other already configured setups following the nixCats format.

<optionalLuaAdditions>
  a flexible set of categories, each containing a list of lua strings,
  or a LIST of sets containing a priority and a string of the format:
  `catname = [ "require('athing')" { config = "require('something')"; priority = 150; } ];`
  (150 is default priority)
  These will be ran after sourcing your init.lua
  It is not the recommended way to create Lua for this flake,
  but it may be useful in editing flake imports 
  of other already configured setups following the nixCats format.

<bashBeforeWrapper>
  a flexible set of categories, each containing arbitrary Bash code
  to run before the wrapper starts within the wrapper's Bash environment.
  # WARNING: only use this if you know what you are doing and why you need
  to do it. Whenever possible, use `wrapperArgs` or `extraWrapperArgs` instead.

<extraCats>
  a flexible set of categories, each containing a list of attribute paths,
  specified as lists of strings. Thus each category would contain a list of
  lists of strings.
  Allows inclusion of extra categories contingent on each lists inclusion in the package,
  and is useful for creating default values for subcategories.
  For more info, see below at
  :h |nixCats.flake.outputs.categoryDefinitions.default_values|
  # WARNING: use of categories argument in this set will cause infinite recursion
  # The categories argument of this function is the FINAL value.
  # You may use it in any of the other sets.

<propagatedBuildInputs> 
  a flexible set of categories, each containing internal BUILD dependencies.
  Will not be available to the PATH unless in a devShell.
  # WARNING: USING THIS SECTION WILL CAUSE NVIM TO BUILD FROM SOURCE.
}

In essence, the contents of each set listed here are filtered
based on the packageDefinitions set you provide, 
whereby including categoryname = true; you enable that category.
:help |nixCats.flake.outputs.packageDefinitions|

It will remove duplicate items, so feel free to include the same thing in
multiple categories if it suits your purposes.

It does this recursively. (explained below)

If, inside one of these main sets, you had another set,
it would consider that a subcategory, and you could enable it
just like you do with a normal category, by setting a value with the
corresponding attribute path to true in the category
set of |nixCats.flake.outputs.packageDefinitions|.
You can nest them as much as you like, or just have a category that is a
single derivation.

                            *nixCats.flake.outputs.categoryDefinitions.schemas*

 You may also use the variables passed to your categoryDefinitions function
 to get access to the set of categories and settings that are being
 used to define the current package being built!
>nix
    themer = with pkgs.vimPlugins;
      (builtins.getAttr packageDef.categories.colorscheme {
          # Theme switcher without creating a new category
          "onedark" = onedark-vim;
          "catppuccin" = catppuccin-nvim;
        }
      );
<
  In addition to all this, if a plugin is defined within a list, it may
  instead be defined within an attribute set that also contains config
  to be ran after sourcing init.lua and optionalLuaAdditions
  to do this, you may use the following syntax in opt or start sections: >nix
    [
      # you may add a plugin to a category list in any of these ways
      { plugin = derivation; config.lua = ""; config.vim = "";}
      { plugin = derivation; config = ""; type = "<viml or lua>"; }
      { plugin = derivation; config = ""; } # defaults to viml
      { plugin = derivation; }

      # all the above options can also accept an optional = bool;
      # to override its presence in either startupPlugins or optionalPlugins

      # they can also accept a name = string; to override its name

      # they can also accept a priority = integer; with low being first
      # and default of 150
      # if they contain a config value, it will be ran in that order.

      # they also may contain a pre = true in order to be ran BEFORE init.lua

      derivation
      # plain derivation does not need to be in a list, but it should be
      # anyway. It could be on its own though and would act as its own
      # category.
    ]
<
                            *nixCats.flake.outputs.categoryDefinitions.default_values*

There are 2 ways of creating default values in nixCats.

#1 Implicit: when value is in another section of categoryDefinitions

If in your categoryDefinitions you had the following:
>nix
    environmentVariables = {
      test = {
        subtest1 = {
          CATTESTVAR = "It worked!";
        };
        subtest2 = {
          CATTESTVAR3 = "It didn't work!";
        };
      };
    };
    extraWrapperArgs = {
      test = [
        '' --set CATTESTVAR2 "It worked again!"''
      ];
    };
<
And in your packageDefinitions set, under categories, you had the following:
>nix
    test = {
      subtest1 = true;
    };
<
you could echo $CATTESTVAR and $CATTESTVAR2 in your terminal to see them.
However you could not echo $CATTESTVAR3.

All items that are not attributes of the parent set will be included
when you enable a subcategory. This includes lists, strings, functions, etc...

However, attributes will not and you must explicitly enable all attributes of
a subcategory if you set even 1 explicitly.

Thus to include CATTESTVAR3, you would have to enable it like so: >nix
    test = {
      subtest1 = true;
      subtest2 = true;
    };
< However, those are all the items in the test category.
So instead we can do this to enable all the subcategories in test. >nix
    test = true;
<
This applies in many situations. Take this one for example.
>nix
    lspsAndRuntimeDeps = {
      neonixdev = {
        inherit (pkgs)
<          nix-doc nil lua-language-server nixd; >nix
      };
    };
    startupPlugins = {
      neonixdev = with pkgs.vimPlugins; [
        neodev-nvim
        neoconf-nvim
      ];
    };

< If you were to put the following in your `packageDefinitions`: >nix
    neonixdev.nix-doc = true;
<
neodev-nvim and neoconf-nvim would still be included.
However, nil, lua-language-server, and nixd would not be!
You would need to pick which of those you wanted separately.
Sometimes this is the desired behavior.
Sometimes it is not and a list of packages would be better suited.

This leads us to our second way to make a default value:

#2 Explicit: using `extraCats` section of `categoryDefinitions`.

The `extraCats` section of `categoryDefinitions` contains categories of attribute
paths. If that category is defined, the categories specified by the attribute
paths will also be enabled. This means you could make it so that if you
included the go category, it could then enable `debug.go` and `lsp.go` for you.
But in addition to that, it can be combined with the implicit form of creating
default values above in an interesting way.
>nix
  categoryDefinitions = { pkgs, settings, categories, extra, name, ... }@packageDef: {
    lspsAndRuntimeDeps = {
      debug = with pkgs; {
        go = [ delve ];
      };
      go = with pkgs; [
        gopls
        gotools
        go-tools
        gccgo
      ];
    };
    startupPlugins = {
      debug = with pkgs.vimPlugins; {
        default = [
          nvim-dap
          nvim-dap-ui
          nvim-dap-virtual-text
        ];
        go = [ nvim-dap-go ];
      };
    };
    # WARNING: use of categories argument in this set will cause infinite recursion
    # The categories argument of this function is the FINAL value.
    # You may use it in any of the other sets.
    extraCats = {
      # due to the implicit form of default values in different sections,
      # this will enable debug.default
      # if any subcategory of debug is enabled
      # thus, enabling debug.go would also enable debug.default
      debug = [
        [ "debug" "default" ]
      ];
      # and if go is enabled, it enables debug.go
      # which then enables debug.default
      go = [ # <- must be in a list
        [ "debug" "go" ]
      ];
    };
  };
<
If you wish to only enable a value via extraCats if multiple other categories
are enabled, the categories in extraCats also accept a set form!
>nix
  extraCats = {
    # if target.cat is enabled, the list of extra cats is active!
    target.cat = [ # <- must be a list of (sets or list of strings)
      # list representing attribute path of category to enable.
      [ "to" "enable" ]
      # or as a set
      {
        cat = [ "other" "toenable" ]; #<- required if providing the set form
        # all below conditions, if provided, must be true for the `cat` to be included

        # true if any containing category of the listed cats are enabled
        when = [ # <- `when` conditions must be a list of list of strings
          [ "another" "cat" ]
        ];
        # true if any containing OR sub category of the listed cats are enabled
        cond = [ # <- `cond`-itions must be a list of list of strings
          [ "other" "category" ]
        ];
      }
    ];
  };
<
---------------------------------------------------------------------------------------
Package Generation:                           *nixCats.flake.outputs.packageDefinitions*

generate packages by calling that builder function we just created.
Place them in the packageDefinitions set.

First, pick the set of settings you wish to include.

Then, pass it a set of named boolean values like this:
`{ categoryname1 = true; categoryname2 = false; etc... }`
False may be omitted. True may not.
Only true matters for what plugins will be added.

These categories are defined in the Builder function above 
by placing named lists of plugins in the flexible sets provided.
The category names are the names of those lists. 
Add a new list, then enable the category here.

If you have categories with the same name in 
multiple different sets outlined above in the builder,
all plugins in those categories will be
included when you set "thatname = true;" here.
hence, general = true; will include the general lspsAndDeps category,
as well as the general startupPlugins category.

an example package definition:
>nix
  packageDefinitions = {
    nixCats = { pkgs, name, ... }: {
      setting = {
        wrapRc = true;
        # nvimSRC = inputs.neovim;
        aliases = [ "viCat" ];
      };
      categories = {
        custom = true;
        gitPlugins = true;
        general = true;
        neonixdev = true;

        # this does not have an associated category of plugins, 
        # but Lua can still check for it
        lspDebugMode = false;

        # you could also pass something else and it calls 
        # builtins.toString on it and passes it in as a string
        theBestCat = "says meow!!!";
        # maybe you need to pass a port or path in or something idk.
        # you could :lua =nixCats("theBestCat")
        # this nixCats("path.to.val") is the main category check function
        # and it is built to mirror the Nix category scheme as much as possible
      };
      extra = {
        there_is = "also";
        an_extra = "table";
        for = ''if you dont want the main subcategory get function
          to apply to something, or think it all being in categories is too
          messy
        '';
        you_can = ''nixCats.extra("path.to.val")'';
        for_safer = ''table access via vim.tbl_get'';
      };
    };
  };
<
You can use the nixCats plugin for the set you define here in your Lua
It returns a Lua table of the same format.

see :help |nixCats|

For more nuances on enabling categories and subcategories, see above at
:help |nixCats.flake.outputs.categoryDefinitions.default_values|
and
:help |nixCats.flake.outputs.categoryDefinitions.schemas|

----------------------------------------------------------------------------------------
Settings                                       *nixCats.flake.outputs.settings*

These are the defaults:
>nix
  default_settings = {
    # YOU ARE IN CHARGE OF MAKING SURE THESE ALIASES DO NOT COLLIDE WITH
    # ANYTHING ELSE
    # [ "takes" "a" "list" "of" "strings" "and" "makes" "an" "alias" "for" "each" ];
    aliases = null;

    # so that you can see it in the store
    extraName = "";

    # see :help nixCats.flake.outputs.settings.hosts (the next section)
    hosts = {};

    # do you want to package the Lua from this flake in the store?
    # or would you rather it just read it in your .config/<configDirName>?
    # nixCats and this help will work either way.
    # packages with wrapRc = false are for quick changes to Lua.
    # it is not for being ran from anywhere via nix run, because the config
    # was not wrapped with the program.
    wrapRc = true;
    # wrapRc may also be set as a string.
    # That string will become an environment variable
    # which you are able to set to unwrap the config.
    # and unset to wrap it again, at runtime.
    # requires 1 extra syscall to achieve.

    # What should the name of the folder within standard directories
    # i.e. .config, .local/share, .local/state, .cache, etc... be?
    # This option is very useful when you want 
    # to clone an unwrapped config straight to the .config dir.
    # It is also helpful to prevent other nvim packages sharing data folders.
    # see :help `$NVIM_APPNAME`
    configDirName = "nvim";

    # Only active when wrapRc = false, this option allows you to specify
    # an absolute path to the unwrapped config directory.
    # This is not a Nix path. This is the unwrapped config directory.
    # This means you are going to need to make
    # sure that it points the right place on the current machine.
    unwrappedCfgPath = null;
    # Will not change anything other than config directory, configDirName
    # is still needed for .local/share or .cache and the like

    # use this to pin a specific Neovim version.
    # This one will specify the base Neovim derivation to use.
    neovim-unwrapped = null;
    # This one will just override the src value of the Neovim in nixpkgs
    # import it in flake inputs with flake = false,
    # It will also obviously cause Neovim to build from source.
    nvimSRC = null;

    # These 2 options allow you to choose whether the items from nixCats
    # override your global environment, or the other way around.
    # true will allow them to inherit, false will cause it to override.
    suffix-path = true;
    # ^ causes lspsAndDeps to be added to the END of
    # PATH instead of the start
    suffix-LD = true;
    # ^ causes sharedLibraries to be added to the END of
    # LD_LIBRARY_PATH instead of the start

    # plugins in nixpkgs sometimes have extra dependencies added to
    # .runtimeDeps attribute. By default nixCats will append then to the path,
    # accepts `"suffix"` or `true` to append to the PATH
    # accepts `"prefix"` to prepend to the PATH
    # accepts `false` or `null` to not include them.
    autowrapRuntimeDeps = "suffix";

    # plugins in nixpkgs sometimes have extra lua config added to
    # .passthru.initLua attribute for compatibility.
    # By default nixCats will run them before your configuration.
    # accepts `"prefix"` or `true` to run before your configuration
    # accepts `"suffix"` to run afterwards
    # accepts `false` or `null` to not include them.
    autoconfigure = "prefix";

    # whether to group up treesitter grammars into a single directory,
    # or leave them as separate plugins.
    # Defaults to true as it results in
    # a significant startup time performance boost
    # Works only on grammars that have been passed through
    # pkgs.neovimUtils.grammarToPlugin
    # or pkgs.vimPlugins.nvim-treesitter.withPlugins
    collate_grammars = true;

    # plugins in nixpkgs sometimes have extra plugin dependencies added to
    # .dependencies attribute. By default nixCats will add them.
    # If for some reason you want to avoid that, set this to false.
    autoPluginDeps = true;

    # each package outputs a module via passthru.
    # this will set the namespace for the module options
    # by default will be at config.${packagename}
    moduleNamespace = [ <packagename> ];
  };
<
QUICK TIP: wrapRc

The `wrapRc` option is very useful for testing Lua changes.
It removes the need to stage and rebuild to see your Lua changes reflected.
You will still need to rebuild when making changes to Nix regardless of the
value of `wrapRc`.

However it also means that the Lua isn't going run if it isn't in the right
folder, i.e. when installed and run from GitHub with `nix run`.

If the Lua is not in `vim.fn.stdpath('config')`, `wrapRc = false` will not work.
By default this is `~/.config/nvim` on Linux systems, although we can
change `nvim` to whatever we wish via the `configDirName` setting.

Alternatively, you can set the `unwrappedCfgPath` option to allow the
configuration to be set to an absolute path. You still may want to set
the `configDirName` option anyway to change the data directories,
or explicitly keep it the same on both so that they share stuff like auths.

The most convenient way to use this is the following:
Make a second identical `packageDefinition`, but with `wrapRc` disabled.
Then install both the wrapped one and unwrapped one with different aliases.
When you want to hack in Lua, use unwrapped! When you're done, just rebuild
and go back to the wrapped one.

The `templates/example/flake.nix` file from the example config template
has an example of this with nixCats and regularCats.

Then, when testing Lua changes, you run the other package and have a vanilla
Neovim experience, only rebuilding when you install new packages.

When you are satisfied, simply rebuild and go back to using the main package,
as it was the same except for the single option!

--------------------------------------------------------------------------------------
Remote Host Providers:                   *nixCats.flake.outputs.settings.hosts*

You can bundle anything with nixCats as a host/provider!
Each "host" defined in the hosts set will
create a new section in categoryDefinitions,
and a global variable of your choosing will be set to the path of the host.

Each defined host will also be added to your path as `${nvimname}-${hostname}`

So if your package was named `mynvim`,
enabling the `python3` host will add `mynvim-python3` to your path.

There are some with builtin defaults.
For those, unless you wish to redefine them, you only need to enable them.
`hosts.python3.enable = true`
`hosts.node.enable = true`
`hosts.ruby.enable = true`
`hosts.perl.enable = true`

Lets use `python3`, as an example of a host definition.

It will create a section in categoryDefinitions called `python3` you can use.
The things defined within it will wrap only that host.
>nix
  categoryDefinitions = { pkgs, settings, categories, name, ... }@packageDef: {
    python3 = {
      wrapperArgs = {
        somecatname = [
          [ "--unset" "PYTHONSAFEPATH" ]
        ];
      };
      extraWrapperArgs = { # <- the same as wrapperArgs but unescaped
        somecatname = [
          "--prefix PATH : ${pkgs.lib.makeBinPath [ pkgs.vulkan-loader ]}"
        ];
      };
      envVars = {
        somecatname = {
          MY_VAR = "somevalue";
        };
      };
      # only defined if settings.hosts.python3.path is a function
      # If function passed to the settings.hosts.python3.path function
      # is called with null as an argument,
      # libraries categories no longer accept functions
      libraries = {
        somecatname = [
          (p: [p.pytest])
        ];
      };
    };
  }
<
The definition for the `python3` host would look like this when fully spelled out:
>nix
  packageDefinitions = {
    somename = {pkgs, name, ...}: {
      settings = {
        hosts = {
          python3 = {
            enable = true; # <- not set by default

            # REQUIRED:
            # path can be a string,
            # or a set:
            # { value = pkgs.python3; args = [ "extra" "wrapper" "args" ]; nvimArgs = [ "for" "nvim" "itself" ]; }
            # or a function that returns either type.
            # If not a function, the ${name}.libraries categoryDefinitions section is ignored
            path = depfn: {
              value = (pkgs.python3.withPackages (p: depfn p ++ [p.pynvim])).interpreter;
              args = [ "--unset" "PYTHONPATH" ];
            };
            # depfn returns the result of filtering the
            # python3.libraries section by categories

            # the vim.g variable to set to the path of the host.
            global = "python3_host_prog";
            # accepts only a string.
            # the default value is "${name}_host_prog"
            # and can be omitted if that is the desired value

            # grabs the named attribute from all included plugins, valid only if path is a function,
            # included dependencies are returned by the
            # function your path function recieves in addition to items from ${name}.libraries
            pluginAttr = "python3Dependencies";
            # accepts a string, or null.
            # defaults to null
            # and can be omitted if that is the desired value

            # If explicitely disabled, will set this vim.g variable to 0
            # This is for disabling healthchecks for a provider.
            # Variable only set if host.${name}.enable = false
            # can be set to null to prevent it from being set regardless of enable value
            disabled = "loaded_python3_provider"; # <- the default value
            # accepts a string, or null.
            # the default value is "loaded_${name}_provider"
            # and can be omitted if that is the desired value
          };
        };
      };
    };
  };
<
You can bundle and wrap anything this way!
>nix
  packageDefinitions = {
    packagename = { pkgs, name, mkPlugin, ... }: {
      categories = {
      };
      settings = {
        hosts = {
          neovide = {
            # Will create a `packagename-neovide` in your path that launches the
            # package named `packagename` in this case.
            enable = true;
            path = {
              value = "${pkgs.neovide}/bin/neovide";
              args = [ "--add-flags" "--neovim-bin ${name}" ];
            };
          };
        };
      };
      extra = {};
    };
  };
<
Defaults:
>nix
  defaults = {
    python3 = {
      path = depfn: {
        value = (pkgs.python3.withPackages (p: depfn p ++ [p.pynvim])).interpreter;
        args = [ "--unset" "PYTHONPATH" ];
      };
      pluginAttr = "python3Dependencies";
    };
    node = {
      path = {
        value = "${pkgs.neovim-node-client or pkgs.nodePackages.neovim}/bin/neovim-node-host";
        nvimArgs = [ "--suffix" "PATH" ":" "${pkgs.nodejs}/bin" ];
      };
    };
    perl = {
      path = depfn: "${pkgs.perl.withPackages (p: depfn p ++ [ p.NeovimExt p.Appcpanminus ])}/bin/perl";
    };
    ruby = {
      path = let
        rubyEnv = pkgs.bundlerEnv {
          name = "neovim-ruby-env";
          postBuild = "ln -sf ${pkgs.ruby}/bin/* $out/bin";
          gemdir = "${pkgs.path}/pkgs/applications/editors/neovim/ruby_provider";
        };
      in {
        value = "${rubyEnv}/bin/neovim-ruby-host";
        nvimArgs = [
          "--set" "GEM_HOME" "${rubyEnv}/${rubyEnv.ruby.gemPath}"
          "--suffix" "PATH" ":" "${rubyEnv}/bin"
        ];
      };
    };
  };
<
--------------------------------------------------------------------------------------
Neovim Builder Creation:                        *nixCats.flake.outputs.builder*

Now we define our builder function.
We inherit `utils.baseBuilder` which is
a function that takes five arguments. It is defined in `./builder`.
Right now we are going to call it with just the first four arguments. This will
leave us with a function that takes 1 argument.
That argument is the name of the Neovim package to be packaged.

1. The path to the Lua to include (in the flake, we use the self variable to get
     this path and wrap the Lua when `wrapRc = true`)

2. A set containing parameters for the pkgs to be used:
  It takes 2 forms. You can either pass it a `nixpkgs` and a `system` and it
  will resolve the `pkgs` for you and pass it to your `categoryDefinitions` and
  `packageDefinitions`,
  or you can pass it a `pkgs` instead to inherit the values and do the same.

  You may also provide a `dependencyOverlays` list to add `overlays` for nvim only,
  `extra_pkg_config` (maps to the config argument to `import nixpkgs { ... }`),
  `nixCats_passthru` (extra items to put into passthru in the final drv),
  and `extra_pkg_params` (contains any fields in `import nixpkgs { ... }` not mentioned).

3. our function that takes an individual package definition
     and returns a set of categoryDefinitions.

4. our set of `packageDefinitions` see: |nixCats.flake.outputs.packageDefinitions|

It is now a function that takes a name, and returns your chosen Neovim package.
>nix
  packages = nixpkgs.lib.genAttrs nixpkgs.lib.platforms.all (system: let
    # create our builder for our exports
    nixCatsBuilder = utils.baseBuilder luaPath {
      inherit nixpkgs system dependencyOverlays extra_pkg_config;
    } categoryDefinitions packageDefinitions;
  in {
    # it can take a name of a package in packageDefinitions
    # and return the package!
    default = nixCatsBuilder defaultPackageName;
  });
<
>nix
  packages = nixpkgs.lib.genAttrs nixpkgs.lib.platforms.all (system: let
    # create our pkgs to pass to builder
    pkgs = import nixpkgs {
      inherit system;
      overlays = dependencyOverlays;
      config = extra_pkg_config;
    };
    # create our builder for our exports
    nixCatsBuilder = utils.baseBuilder luaPath {
      /* you can still use dependencyOverlays here and such as well to add */
      inherit pkgs; # <- but here we are just going to inherit the value.
    } categoryDefinitions packageDefinitions;
  in {
    # it can take a name of a package in packageDefinitions
    # and return the package!
    default = nixCatsBuilder defaultPackageName;
  });
<
---------------------------------------------------------------------------------------
Flake Exports and Export options               *nixCats.flake.outputs.exports*

They look something like this:
>nix
  # this first section is the outputs we
  # want to wrap with the ${system} variable
  utils.eachSystem nixpkgs.lib.platforms.all (system: let
    # this is the builder (see :h nixCats.flake.outputs.builder above):
    nixCatsBuilder = utils.baseBuilder luaPath {
      inherit nixpkgs system dependencyOverlays extra_pkg_config;
    } categoryDefinitions packageDefinitions;
    # then it takes our categoryDefinitions and packageDefinitions

    # then we build a package to serve as the default one by providing its name.
    defaultPackage = nixCatsBuilder defaultPackageName;

    # this is just for using utils in the following section such as pkgs.mkShell
    # The one used to build Neovim is resolved inside the builder
    # and is passed to our categoryDefinitions and packageDefinitions
    pkgs = import nixpkgs { inherit system; };
    # as you can see, "resolve pkgs" does not mean anything fancy.
    # however, with overlays and system variable,
    # sometimes you can get yourself in a loop when
    # doing more advanced things. So this flake takes care of that for you.
    # it will make sure pkgs is passed to the categoryDefinitions and packageDefinitions
  in
  {
    # these outputs will be wrapped with ${system} by utils.eachSystem

    # this will make a package out of each of the packageDefinitions defined above
    # and set the default package to the one passed in here.
    packages = utils.mkAllWithDefault defaultPackage;

    # choose your package for devShell
    # and add whatever else you want in it.
    devShells = {
      default = pkgs.mkShell {
        name = defaultPackageName;
        packages = [ defaultPackage ];
        inputsFrom = [ ];
        shellHook = ''
        '';
      };
    };

  }) // {

    # these outputs will be NOT wrapped with ${system}

    # now we can export some things that can be imported in other
    # flakes, WITHOUT needing to use a system variable to do it.
    # and update them into the rest of the outputs returned by the
    # eachSystem function.

    # this will make an overlay out of each of the packageDefinitions defined
    # and set the default overlay to the one named here.
    overlays = utils.makeOverlays luaPath {
      # we pass in the things to make a pkgs variable to build nvim with later
      inherit nixpkgs dependencyOverlays extra_pkg_config;
      # and also our categoryDefinitions
    } categoryDefinitions packageDefinitions defaultPackageName;

    # we export a NixOS module to allow configuration from configuration.nix
    # allows you to either inherit values from your main flake, or start fresh
    # It requires the system variable to build a package but not to build a module!
    nixosModules.default = utils.mkNixosModules {
      inherit dependencyOverlays luaPath defaultPackageName
        categoryDefinitions packageDefinitions nixpkgs;
    };
    # and the same for Home Manager
    homeModule = utils.mkHomeModules {
      inherit dependencyOverlays luaPath defaultPackageName
        categoryDefinitions packageDefinitions nixpkgs;
    };
    # and we export these so its super easy to grab them later.
    inherit utils;
    inherit (utils) templates;
  };
<
                                  *nixCats.flake.outputs.utils*

The <utils> set exports all the functions used in creating the format in the
templates, including the main builder!
(see :h |nixCats.flake.outputs.builder| for builder explanation)

In the interests of not repeating ourselves,
a list of most functions exported in the <utils> set
can be found here:
https://nixcats.org/nixCats_utils.html

Missing from that list however,
is an explanation of the internal <n2l> library
nixCats uses to create the nixCats Lua plugin!

The library fully escapes all items passed to it,
so usually you can't execute lua code in them.
But you may still explicitly pass it lua code to execute at runtime
by declaring them as inline lua types!

An intricate explanation of the full set
of features the <n2l> library contains are below.

All other functions made available by
the <utils> set are explained in the documentation
at https://nixcats.org/nixCats_utils.html

                                  *nixCats.flake.outputs.utils.n2l*
<n2l> This is the Nix to Lua library nixCats
uses to create the nixCats Lua plugin
You may wish to use some functions from it.

The library is exported from the <utils> set as `utils.n2l`

It contains <toLua> and <prettyLua> and <uglyLua> which convert Nix to Lua.

it contains a <member> function to determine if a value is a special "inline lua" type
it contains a <typeof> function to determine which special "inline lua" type it is
it contains a <resolve> function which knows how to resolve the types to a string of code
it contains the <default_subtype> name as well.

But of much more interest to you is the types you may declare.

Everything being passed through settings, categories, and extra in packageDefinitions
will be properly escaped. But this also means that
you cannot write any Lua code there.

Luckily, we have some types we can declare that will allow you to do this.

To declare that an item is a Lua value rather than a hard coded one,
you may choose one of these types. To do this, call its constructor!

for example, `types.inline-unsafe` has 1 field, `body`.

To declare one in our settings, categories, and extra sets, it would look
something like this:
>nix
  categories = {
    somecat = utils.n2l.types.inline-unsafe.mk {body = "vim.fn.stdpath('data')"; }`
  }
<
`inline-safe` is the default type, and it gets to define a shorthand form.
>nix
  categories = {
    somecat = utils.n2l.types.inline-safe.mk "vim.fn.stdpath('data')";`
  }
<
These are all the types, each one has an associated `mk`
function to create a value of that type,
which accepts the fields listed here, defined with default values.
>nix
  # creates an inline Lua value in a way that cant break the table
  inline-safe = {
    default = (v: if v ? body then v else { body = v; });
    fields = { body = "nil"; };
    format = LI: "assert(loadstring(${luaEnclose "return ${LI.expr.body or LI.expr or "nil"}"}))()";
  };
  # iterpolates whatever string you provide into the table raw
  inline-unsafe = {
    fields = { body = "nil"; };
    format = LI: "${LI.expr.body or "nil"}";
  };
  # creates a function with args of the names given in args list
  # does so in a way where you cannot accidentally break the table
  function-safe = {
    fields = { body = "return nil"; args = []; };
    format = LI: 
      ''assert(loadstring(${luaEnclose ''return (function(${fixargs (LI.expr.args or [])}) ${LI.expr.body or "return nil"} end)''}))()'';
  };
  # creates a function with args of the names given in args list
  # interpolates the body segment raw, just like inline-unsafe, but in a function
  function-unsafe = {
    fields = { body = "return nil"; args = []; };
    format = LI: ''(function(${fixargs (LI.expr.args or [])}) ${LI.expr.body or "return nil"} end)'';
  };
  with-meta = {
    fields = {
      table = {}; # <- the table you are adding
      meta = {}; # <- the metatable you want to add to it (in Nix)
      newtable = null; # <- if you want to specify a different first arg to setmetatable
      tablevar = "tbl_in"; # <- varname to refer to the table, to avoid translating multiple times
    };
    format = LI: opts: let
      metaarg1 = if LI.expr.newtable or null == null then LI.expr.tablevar or "{}" else toLuaFull opts LI.expr.newtable;
      result = inline.types.function-unsafe.mk {
        args = [ (LI.expr.tablevar or "tbl_in") ];
        body = ''return setmetatable(${metaarg1}, ${toLuaFull opts LI.expr.meta})'';
      };
    in "${toLuaFull opts result}(${toLuaFull opts LI.expr.table})";
  };
<

Some more useage examples:
>nix
  exampleSafeFunc = utils.n2l.types.function-safe.mk {
    args = [ "hello" ];
    body = /*lua*/ ''
      print(hello)
      return hi
    '';
  };
  exampleUnsafeFunc = utils.n2l.types.function-unsafe.mk {
    args = [ "hi" "hello" ];
    body = /*lua*/ ''
      print(hi)
      print(hello)
      return hi .. hello
    '';
  };
  };
  funcResults = {
    test1 = utils.n2l.types.inline-safe.mk ''${utils.n2l.resolve exampleSafeFunc}("Hello World!")'';
  };
  lua_table_with_meta = utils.n2l.types.with-meta.mk (let
    tablevar = "tbl_in";
  in {
    table = {
      this = "is a test table";
      inatesttable = "that will be translated to a Lua table with a metatable";
    };
    # to avoid translating the table multiple times,
    # define a variable name for it in Lua. Defaults to "tbl_in"
    inherit tablevar;
    meta = {
      # __call in Lua lets us also call it like a function
      __call = utils.n2l.types.function-unsafe.mk {
        args = [ "self" "..." ];
        body = ''
          print("This table is named ${tablevar}")
          return ${tablevar}.this
        '';
      };
    };
    # you can change it to set the metatable of
    # and return a different table instead.
    # sometimes done so that access always uses __index function
    newtable = null; # <- default val, sets metatable of tablevar
  });
<
---------------------------------------------------------------------------------------
vim:tw=78:ts=8:ft=help:norl:
