=================================================================================
INTRODUCTION                              *nixCats.flake.nixperts.nvimBuilder*

Wait, why is this code? 
I could not find a better way to incorporate code examples without
just doing this and including more comments than code.

--------------------------------------------------------------------------
                                *nixCats.flake.nixperts.nvimBuilder.arguments*

  # this function takes a set with the following items:
  # our arguments ? and their default values
>nix
  { 
    self
    , pkgs
    , categories ? {}
    , settings ? {}

    , startupPlugins ? {}
    , optionalPlugins ? {}
    , lspsAndRuntimeDeps ? {}
    , propagatedBuildInputs ? {}
    , environmentVariables ? {}
    , extraWrapperArgs ? {}
<
    # these ones take sets of lists of FUNCTIONS,
    # and those functions return lists of packages.
    # i.e. (_:[]) as a default argument
    # so now you can put categories of lists of them in
    # and they will be sorted like everything else
    # Idk why they work that way, 
    # but just made a function to filter them, 
    # call them, then combine the outputs.
    # and I pass that in instead.
    # the source says:
      /* the function you would have passed to python.withPackages */
>nix
    , extraPythonPackages ? {}
    , extraPython3Packages ? {}
    # same thing except for lua.withPackages
    , extraLuaPackages ? {}
    }:
    let
<
      # when packaging, one of these is passed, 
      # but we dont want to have to define all of them every time.
      # so we update the default config with whatever new options were passed
>nix
      config = {
        wrapRc = true;
        RCName = "";
        viAlias = false;
        vimAlias = false;
        withNodeJs = false;
        withRuby = true;
        extraName = "";
        withPython3 = true;
        configDirName = "nvim";
      } // settings;
<
--------------------------------------------------------------------------
                                   *nixCats.flake.nixperts.nvimBuilder.opener*

    # package the entire runtimepath as plugin
    # see :h rtp
    # it simply copies each of the folders mentioned the same as we do for luaAfter
>nix
    LuaConfig = pkgs.stdenv.mkDerivation {
      name = config.RCName;
      builder = builtins.toFile "builder.sh" ((import ./utils.nix).runtimepathcopier self);
    };
<
    # We package after separately to make sure it is run last
>nix
    luaAfter = pkgs.stdenv.mkDerivation {
      name = "${config.RCName}_after";
      builder = builtins.toFile "builder.sh" ''
          source $stdenv/setup
          mkdir -p $out/
          if [ -d ${self}/after ]; then
             cp -r ${self}/after/* $out/
          fi
      '';
    };
<
    # see :help `nixCats`
    # here is where nixCats is generated
    # it uses some recursive stuff in utils to print a lua table to a file.
    # Thats it. Also it defines a user command.
>nix
    nixCats = pkgs.stdenv.mkDerivation {
      name = "nixCats";
      builder = let
        cats = builtins.toFile "nixCats.lua" ''
            vim.api.nvim_create_user_command('NixCats', 
            [[lua print(vim.inspect(require('nixCats')))]] , 
            { desc = 'So Cute!' })
            return ${(import ./utils.nix).luaTablePrinter categories}
          '';
      # It installs itself and these docs to wherever it installs to.
      in builtins.toFile "builder.sh" ''
        source $stdenv/setup
        mkdir -p $out/lua
        mkdir -p $out/doc
        cp ${cats} $out/lua/nixCats.lua
        cp -r ${self}/nixCatsHelp/* $out/doc
      '';
    };
    # check if we should wrap the lua config, or use regular directory
    wrapRc = if config.RCName != "" then config.wrapRc else false;

    # and create our customRC to call it
    # This makes sure our config is loaded first and our after is loaded last
    # and it also requires the chosen directory or file in the lua directory
    customRC = if wrapRc then ''
        packadd ${config.RCName}
        lua require('${config.RCName}')
        set runtimepath+=${luaAfter}
      '' else "";

    # only include LuaConfig if we want it
    extraPlugins = if wrapRc then [ nixCats LuaConfig ] else [ nixCats ];
<
---------------------------------------------------------------------------------
                             *nixCats.flake.nixperts.nvimBuilder.basicFlatmap*

    # this is what allows for dynamic packaging in flake.nix
    # It includes categories marked as true, then flattens to a single list
>nix
    filterAndFlatten = (import ./utils.nix)
          .filterAndFlattenAttrsOfLists pkgs categories;
<
    # we can use that function to filter many of the options.
    # anything that has an argument in the wrapper and 
    # is a list of categories of packages, you can filter this way
>nix
    buildInputs = [ pkgs.stdenv.cc.cc.lib ] ++ filterAndFlatten propagatedBuildInputs;
    start = extraPlugins ++ filterAndFlatten startupPlugins;
    opt = filterAndFlatten optionalPlugins;

    # I didnt add stdenv.cc.cc.lib, so I would suggest not removing it.
    # It has cmake in it among other things.
<
---------------------------------------------------------------------------------
                           *nixCats.flake.nixperts.nvimBuilder.mapWrapArgCats*

    # This one filters and flattens like above but for attrs of attrs 
    # and then maps name and value
    # into a list based on the function we provide it.
    # its like a flatmap function but with a built in filter for category.
    # you may use this to create entirely new 
    # categories in the builder for wrapper arguments
    # more info on wrapper arguments below.
>nix
    filterAndFlattenWrapAttrs = (import ./utils.nix)
          .FilterAttrsOfAttrsFlatMapInner pkgs categories;
<
    # This one filters and flattens attrs of lists and then maps value
    # into a list based on the function we provide it.
    # it the same as above but for a mapping function with 1 argument
    # because the inner thing we are mapping is a list not a set.
>nix
    filterAndFlattenWrapLists = (import ./utils.nix)
          .FilterAttrsOfListsFlatMapInner pkgs categories;
<
    # Each of these 2 functions actually take 4 arguments. But actually,
    # they are 4 separate functions inside one another.
    # therefore we can supply it with the first 2 arguments, then supply it
    # with a function to map, then later supply it with the final argument.
    # currently, it now works very much like a regular flatmap function.
    # it now takes a function, and a set of categories of stuff.


---------------------------------------------------------------------------------
                          *nixCats.flake.nixperts.nvimBuilder.usingWrapArgMap*

    # we are going to provide a function to map name and value
    # into a wrapper argument that sets an environment variable
>nix
    FandF_envVarSet = filterAndFlattenWrapAttrs 
          (name: value: ''--set ${name} "${value}"'');
<
    # and this one we define a function that just passes an arg through.
    # this one takes in a set of lists rather than a set of sets
>nix
    FandF_passWrapperArgs = filterAndFlattenWrapLists (value: value);
<

    # you can use filterAndFlattenWrapLists and its attr set counterpart in order
    # to create new sets of categories in the flake's builder function
    # that are to do with wrapper args.

    # you would add the set as an argument to this file, then, create one of these.
    # to create one, pass it a new wrapping function. I.E. 
    # FandFpassFlags = filterAndFlattenWrapLists (value: "--add-flags ${value}")

    # and this is how we add our lsps/runtime dependencies/whatever we need available at runtime
>nix
    FandF_WrapRuntimeDeps = filterAndFlattenWrapLists (value:
      ''--prefix PATH : "${pkgs.lib.makeBinPath [ value ] }"''
    );
<
    # this next part takes those wrapper args and 
    # concatenates them together with a space
    # More info at:
# https://github.com/NixOS/nixpkgs/blob/master/pkgs/build-support/setup-hooks/make-wrapper.sh

    # we will send this to our rendition of the official wrapNeovim stable
    # which is just pkgs.wrapNeovim with an extra argument
>nix
    # this sets the name of the folder to look for nvim stuff in
    configDirName = if config.configDirName != "nvim" &&
      config.configDirName != null && config.configDirName != ""
        then [ ''--set NVIM_APPNAME "${config.configDirName}"'' ] else [];

    extraMakeWrapperArgs = builtins.concatStringsSep " " (
      # We call the functions above and add them into a big list
      # which we then call concatStringsSep " " on
      configDirName
      ++ (FandF_WrapRuntimeDeps lspsAndRuntimeDeps)
      ++ (FandF_envVarSet environmentVariables)
      ++ (FandF_passWrapperArgs extraWrapperArgs)


    );
<
---------------------------------------------------------------------------------
                            *nixCats.flake.nixperts.nvimBuilder.extraPackages*

    # extraPythonPackages and the like require FUNCTIONS that return lists.
    # so we make a function that returns a function that returns lists.
    # this is used for the fields in the wrapper where the default value is (_: [])
    # This just makes a function that calls all the functions we want, 
    # then combines the results into 1 list.
>nix
    combineCatsOfFuncs = sect:
      (x: let
        appliedfunctions = builtins.map (value: (value) x ) (filterAndFlatten sect);
        combinedFuncRes = builtins.concatLists appliedfunctions;
        uniquifiedList = pkgs.lib.unique combinedFuncRes;
      in
      uniquifiedList);
<
---------------------------------------------------------------------------------
                         *nixCats.flake.nixperts.nvimBuilder.generatingNeovim*

    # here is where we add our propagated build dependencies
>nix
    myNeovimUnwrapped = pkgs.neovim-unwrapped.overrideAttrs (prev: {
      propagatedBuildInputs = buildInputs;
    });
    in
    # add all our stuff, and wrap it all up!
    # the following is just the regular pkgs.wrapNeovim
    # except it also accepts wrapRc as an argument
  (import ./wrapNeovim.nix).wrapNeovim pkgs myNeovimUnwrapped {
    inherit wrapRc extraMakeWrapperArgs;
    inherit (config) vimAlias viAlias withRuby extraName withNodeJs;
    configure = {
      inherit customRC;
      packages.myVimPackage = {
        inherit start;
        inherit opt;
      };
    };

    # the extra packages arguments take (_: []) as a default argument

      /* the function you would have passed to python.withPackages */
    extraPythonPackages = combineCatsOfFuncs extraPythonPackages;
      /* the function you would have passed to python.withPackages */
    withPython3 = config.withPython3;
    extraPython3Packages = combineCatsOfFuncs extraPython3Packages;
      /* the function you would have passed to lua.withPackages */
    extraLuaPackages = combineCatsOfFuncs extraLuaPackages;
  }
<
===========================================================================================================
vim:tw=78:ts=8:ft=help:norl:
